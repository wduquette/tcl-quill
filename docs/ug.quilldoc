<document "Quill <version> User's Guide">

By Will Duquette<br>
September, 2014<p>

<hrule>
<contents>
<hrule>

<do {
# Define some infrastructure.
proc tclref {name} {
	return [link http://www.tcl.tk/man/tcl8.6/TclCmd/$name.htm ${name}(n)]
}
# For comment bars
proc == {args} {hrule}

# For project-relative paths
proc root {path} {
	return "[tt][i project]/[expand $path][/tt]"
}

}>

<preface intro "Introduction">

TODO: Why Quill came to be written.

<preface ack "Acknowledgements">

Many thanks to the following people who have helped with Quill development:<p>

<ul>
<li> Ted Brunzie, for help with virtual machines
<li> Stephan Effelsberg, for Windows testing and diagnosis
<li> Andreas Kupries, for teapot troubleshooting
</ul>

<section over "Quill Overview">

TODO: Gosh, there's a lot of work to be done here.<p>

<section over.tree "The Project Tree">
<section over.pfile "The Project File">

<section projfile "The Project File">

<== ====================================================================>

<section lib "Library Packages">

This section explains how Quill manages TCL library packages.
A Quill project can contain three different kinds of Tcl library:

<ul>
<li> <b Provided packages>: I.e., those written to be used by other 
     projects.  These are named in the <xref projfile "project file">
     using the <xref project(5)#provide> statement.<p>

<li> <b Application implementation packages>:  Each application in a Quill
     project is represented as a loader script and an implementation
     package.  If the application is called <tt><i name></tt>, then its 
     implementation package is called <tt><i name>app</tt>.<p>

<li> <b Application infrastructure packages>:  A project may define a number
     of library packages to be used solely by the project's own 
     applications.<p>
</ul>

A project library called <i name>, of any of these three kinds, resides in
the project's <root "lib/<i name>"> directory.<p>

At least one library package is included in each new project.  Additional
packages can be added using the <tt quill add> command (not yet implemented)
or by hand, by copying an existing library.<p>

Quill has some very specific expectations of project library packages; for
the details, see the following subsections.<p>

<section lib.pkgIndex "The 'pkgIndex.tcl' File">

Every library package will have its <tt pkgIndex.tcl> file.  These are usually
created with the library package by Quill.  Here is a typical library 
package:<p>

<listing>
#-------------------------------------------------------------------------
# TITLE: 
#    pkgIndex.tcl
#
# PROJECT:
#    my-project: Your project description <mark A>
#
# DESCRIPTION:
#    mylib(n): pkgIndex file
#
#    Generated by Quill
#
#-------------------------------------------------------------------------

# -quill-ifneeded-begin <mark B> DO NOT EDIT BY HAND <mark C>
package ifneeded mylib 1.2.3 <mark D> [list source [file join $dir pkgModules.tcl]] <mark E>
# -quill-ifneeded-end <mark B>
</listing>

<topiclist>
<topic "<bigmark A>">
Quill uses your project's metadata when creating the file header.<p>
</topic>

<topic "<bigmark B>">
These are Quill block markers.  They are used to mark code segments that
Quill will update automatically, as needed.<p>
</topic>

<topic "<bigmark C>">
The contents of this kind of block (<tt quill-ifneeded-*>) is replaced in
its entirety; do not edit the code between the markers.<p>
</topic>

<topic "<bigmark D>">
The <tt package ifneeded> command loads the package's code when TCL is asked
to <tt package require> it, and references the package's name and version
number.  The version number of a package in a Quill project is always the 
same as the project version number.  When the version number changes, 
Quill will update this command with the latest version number.<p>
</topic>

<topic "<bigmark E>">
The package's code is loaded by calling the module's 
<tt pkgModules.tcl> file.  See <xref lib.pkgmodules>.<p>
</topic>

</topiclist>

<section lib.pkgmodules "The 'pkgModules.tcl' File">

A package's code is loaded by sourcing the package's
<tt pkgModules.tcl> file, which then sources the individual package
modules.  The <tt pkgModules.tcl> file is usually created automatically
by Quill, and then updated by the user as needed (see below).  Here is
a typical <tt pkgModules.tcl> file:<p>

<listing>
#-------------------------------------------------------------------------
# TITLE: 
#    pkgModules.tcl
#
# PROJECT:
#    my-project: Your project description <mark A>
#
# DESCRIPTION:
#    mylib(n): Package Loader
#
#    Generated by Quill
#
#-------------------------------------------------------------------------

#-------------------------------------------------------------------------
# Provide Package

# -quill-provide-begin <mark B> DO NOT EDIT BY HAND <mark C>
package provide mylib 1.2.3 <mark D>
# -quill-provide-end <mark B>

#-------------------------------------------------------------------------
# Require Packages

# -quill-require-begin <mark B> INSERT PACKAGE REQUIRES HERE <mark E>
package require snit 2.3 <mark F>
package require -exact myotherlib 1.2.3 <mark G>
# -quill-require-end <mark B>

#-------------------------------------------------------------------------
# Get the library directory

namespace eval ::mylib:: <mark H> {
    variable library [file dirname [info script]] <mark I>
}

source [file join $::mylib::library mymodule.tcl] <mark J>
...
</listing>

<topiclist>
<topic "<bigmark A>">
Quill uses your project's metadata when creating the file header.<p>
</topic>

<topic "<bigmark B>">
These are Quill block markers.  They are used to mark code segments that
Quill will update automatically, as needed.<p>
</topic>

<topic "<bigmark C>">
The contents of this kind of block (<tt quill-provide-*>) is replaced in
its entirety; do not edit the line between the markers.<p>
</topic>

<topic "<bigmark D>">
The <tt package provide> command notifies TCL that the given version of the
package is available to be required and used.  The version number for a
package in a Quill project is always the same as the project's version 
number, so Quill automatically updates this code when the project
version number changes.<p>
</topic>

<topic "<bigmark E>">
Your package's <tt package require> commands should go between these
<tt quill-require-*> marks, so that Quill can keep the version numbers
up to date.  Quill updates only the lines whose first non-whitespace
tokens are "package require".<p>
</topic>

<topic "<bigmark F>">
In this line, Snit is an external dependency named in the 
<xref projfile "project file"> using the <xref project(5)#require>
statement.  Quill consequently knows the required version number, and
will make sure to keep this command up-to-date with it.<p>
</topic>

<topic "<bigmark G>">
In this line, <tt myotherlib> is another library provided by this same
project.  In this case, Quill not only keeps the version number up-to-date
with the project's version number, it adds the <tt -exact> flag.
<tt myotherlib> might exist in the local teapot repository
as well as in the project tree, and using <tt -exact> ensures that 
<tt mylib> will load the version in the same project tree 
during development and a consistent version when deployed.<p>
</topic>

<topic "<bigmark H>">
Every package defines a namespace of the same name, just as a matter of 
convention.  Provided packages should usually put their code in the 
package namespace; for application and infrastructure packages, it's a
matter of taste.<p>
</topic>

<topic "<bigmark I>">
Every package saves the path its library directory in a variable called
<tt library> in its namespace.  This variable has multiple uses.  If
the package has resources (e.g., image files) that need to be loaded
at runtime, it can find them relative to this path.  And if it isn't
clear which version of a package is being loaded, a glance at the 
<tt library> variable will usually make things plain.<p>
</topic>

<topic "<bigmark J>">
The package's modules should always be sourced using this idiom, which 
is guaranteed to work on all platforms.<p>
</topic>
</topiclist>

There are two temptations to be avoided with regard to this file.

First, do not try to change the file name.  The consistent use of the
name <tt pkgModules.tcl> allows Quill to find it and update it properly
as version numbers change.<p>

Second, do not put your package's implementation at the tail end of the
<tt pkgModules.tcl> file, even if you have only one file.  Instead, put the
implementation in another file or files, and update <tt pkgModules.tcl> 
only when adding or deleting a module or a <tt package require>.<p>

<section lib.modules "Normal Package Modules">

The library package's code goes in one or more normal <tt .tcl> files, 
which are sourced by the package's
<tt pkgModules.tcl> file (see Section <xref lib.pkgmodules>).
They typically look like this:<p>

<listing>
#-------------------------------------------------------------------------
# TITLE: 
#    mymodule.tcl
#
# PROJECT:
#    mylib: Your project description <mark A>
#
# DESCRIPTION:
#    mylib(n): my module for this and that
#
#-------------------------------------------------------------------------

<mark B>

#-------------------------------------------------------------------------
# Exported Commands

namespace eval ::mylib {
    namespace export myproc <mark C>
}

#-------------------------------------------------------------------------
# Commands

# myproc text
#
# Dummy procedure

proc ::mylib::myproc {text} { <mark D>
    puts "Hello, $text!"
}
</listing>

<topiclist>
<topic "<bigmark A>">
Quill uses your project's metadata when creating the file header.
Update it to describe your module as desired.<p>
</topic>

<topic "<bigmark B>">
Notice that there are no <tt package require> or <tt package provide>
commands here.  Those go in <tt pkgModules.tcl>; see 
<xref lib.pkgmodules>.<p>
</topic>

<topic "<bigmark C>">
If you put the module's code in the package namespace, you might want to
export some commands.<p>
</topic>

<topic "<bigmark D>">
This part is up to the user.<p>
</topic>
</topiclist>

<== ====================================================================>

<section testing "Project Testing">

Quill provides easy management of your project test suite using the 
<tclref tcltest> test harness.  To execute all project tests,<p>

<example>
$ quill test
...
</example>

Quill will run all test targets, and output the results. Alternatively,
Quill will run a single test target given its name:<p>

<example>
$ quill test mylib
...
</example>

Test targets are defined by adding subdirectories to <root test/>; 
the name of the subdirectory is the name of the target.<p>

Each test directory contains an <tt all_tests.test> file, and one or
more normal <tclref tcltest> files, e.g., <tt mymodule.test>.  To run
a specific test file, add its name to the command line:<p>

<example>
$ quill test mylib mymodule
</example>

Finally, any options are passed along to <tt tcltest>:<p>

<example>
$ quill test mylib mymodule -match "mytest-1.*"
</example>


<section testing.stdfiles "Standard Test Files">

Each test 
subdirectory is assumed to contain a file called 
<tt all_tests.test>, plus any number of normal <tclref tcltest> files,
e.g., <tt mymodule.test>.<p>

The content of <tt all_tests.test> is pure boilerplate; it simply arranges
to execute all other <tt *.test> files in the directory, each in its 
own instance of the Tcl interpreter, and accumulate the results.  It is
generally created automatically by Quill, or by copying 
<tt all_tests.test> from an existing test subdirectory.<p>

Here is the skeleton of a typical module test script, as created by
Quill:<p>

<listing>
#-------------------------------------------------------------------------
# TITLE:
#    mymodule.test
#
# PROJECT:
#    myproject: Description of my project
#
# DESCRIPTION:
#    mymodule(n): Test Suite
#-------------------------------------------------------------------------

#-------------------------------------------------------------------------
# Load the tcltest package

if {[lsearch [namespace children] ::tcltest] == -1} { <mark A>
    package require tcltest 2.3
    eval ::tcltest::configure $argv
}

namespace import ::tcltest::test <mark B>

#-------------------------------------------------------------------------
# Load the package to be tested

source <mark C> ../../lib/mymodule/pkgModules.tcl <mark D>
namespace import ::mymodule::*

#-------------------------------------------------------------------------
# dummy

test dummy-1.1 {dummy test} -body {
    set a false
} -result {true}
</listing>

There are several things to note in the above listing:<p>

<topiclist>
<topic {<bigmark A>}>
The <tclref tcltest> package is loaded, and any options
passed to <tt quill test> are passed along to <tt tcltest>.<p>
</topic>

<topic {<bigmark B>}>
Only the <tt test> command is imported from the <tt tcltest::> namespace.
Used fully-qualified names for other <tclref tcltest> commands, or edit
this line to import additional commands.<p>
</topic>

<topic {<bigmark C>}>
The test script uses <tt source> to load the package, rather than
<tt package require>; if the library package is installed into the
local environment (not unusual), it can be difficult to ensure that 
<tt package require> always loads the code in the project tree.<p>
</topic>

<topic {<bigmark D>}>
Quill generally creates library packages and test directories together,
and assumes that the tests in the directory are for the package in the
<root lib> subdirectory of the same name.<p>


Also, notice that the test script sources the library package's 
<tt pkgModules.tcl> file.  By convention, all library packages in a 
Quill project have such a file; see <xref lib.pkgmodules> for details.<p>
</topic>
</topiclist>


<section testing.new "Adding New Test Targets">

At present each Quill project contains one test target, for the 
application's implementation package.  Ultimately, you will be
able to use the <tt quill add> command (FIXME) to add new
library packages, as well as new applications (each of which gets its
corresponding implementation package); each library created in this way
will each get its own test directory.<p>

In the meantime, test directories must be added by hand, usually by
copying an existing directory and changing the names.<p>

</document>
