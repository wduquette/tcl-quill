<document "Quill <version> User's Guide">

By Will Duquette<br>
<tt will -at- wjduquette.com><br>
November, 2014<p>

<hrule>
<contents>
<hrule>

<do {
# Define some infrastructure.
proc tclref {name} {
	return [link http://www.tcl.tk/man/tcl8.6/TclCmd/$name.htm ${name}(n)]
}
# For comment bars
proc == {args} {hrule}

# For project-relative paths
proc root {path} {
	return "[tt][i project]/[expand $path][/tt]"
}

# For indented paths in topic headings.
proc topicpath {path} {
    set path "<tt>[string map {+ &nbsp;&nbsp;&nbsp;&nbsp} $path]</tt>"
    return "[topic $path]"
}

proc /topicpath {} {
    return "[/topic]"
}

}>

<preface intro "Introduction">

Quill is a tool for automating the various tasks involved in developing,
testing, documenting, and distributing a modern Tcl/Tk application.  It
was inspired by <link http://leiningen.org Leiningen>, a similar tool for
the Clojure programming language, a tool whose convenience and ease of use
made me distinctly jealous.<p>

Quill is intended for those learning Tcl/Tk for the first time, and also
for those who build libraries or applications in Tcl/Tk that are intended
for use by others.<p>

It is still a young project; if it doesn't yet meet your needs, please
leave an enhancement request at the 
<link https://github.com/wduquette/tcl-quill/issues "Quill issue tracker">.<p>

<preface ack "Acknowledgements">

Many thanks to the following people who have helped with Quill development:<p>

<ul>
<li> Ted Brunzie, for help with virtual machines
<li> Stephan Effelsberg, for Windows testing and diagnosis
<li> Andreas Kupries, for teapot troubleshooting
</ul>

<section over "Quill Overview">

This user's guide assumes that Quill is already installed; see
<link INSTALL.md> for details on how to install Quill.  If you don't
have Quill, you can find the latest release at the
<link https://github.com/wduquette/tcl-quill/releases "Quill Release Page">

Quill will help you do the following things:<p>

<ul>
<li> Set up an initial project tree for your application or library project.
<li> Manage any external dependencies (i.e., library packages) your project
     needs, downloading them from <tt teapot.activestate.com> as needed.
<li> Execute your tests, summarizing the results.
<li> Allow you to exercise your code in an interactive shell.
<li> Allow you to run arbitrary scripts against your code base.
<li> Format your project documentation.
<li> Build your library packages as teapot .zip files, and install them 
     into your local teapot.
<li> Build your applications as starkits or starpacks for your current
     platform, and install them for local use.
<li> Build distribution .zip files.
<li> Build your applications as starpacks against basekits for other 
     platforms.
<li> Manage your collection of basekits.
<li> Manage your local teapot repository.
<li> <b>Test your code, format your documentation, build your libraries
     and applications, and prepare them for distribution, with a single
     command.</b>
</ul>

Of course, you can do almost all of these things without Quill...but Quill
aims to make them so easy that all you need to do is write your code.<p>

<section using "Using Quill">

Quill is a command-line tool with many subcommands, just like so many 
other software development tools.  To see what tools are available, 
enter '<tt quill>' or '<tt quill help>' at the command line.  To get help about a
specific subcommand, enter '<tt>quill help <i subcommand></tt>'.<p> 

<section using.newproject "Starting a New Project">

A Quill <i>project</i> is the collection of files related to a Tcl application
or library package (or both together).  To begin working with Quill, then,
the first thing to do is create a new project.  And the first thing to do
when starting a new project is to choose the most suitable project template.<p>

<i><b FUTURE:> Quill will support multiple project templates.  At present,
it supports a single template, '<tt app>', for a generic application.</i><p>

To create a new project, switch to the parent directory of the new project's
directory tree, and use the '<tt quill new>' tool:<p>

<example>
$ <b cd ~/github>
$ <b quill new app my-project myapp>
...
$ <b cd my-project>
$ <b quill info>
...
</example>

The '<tt quill new>' command takes the project template name ('<tt app>')
and the project name, ('<tt my-project>'), and any additional information 
required by the template (the application name, 'myapp', in this case).  
It creates  a project tree for the project, rooted at 
<tt my-project/> in the current directory.<p>

The '<tt quill info>' command displays the new project's metadata in a 
human-readable form:<p>

<example>
$ <b quill info>
my-project 0.0a0: Your project description

Project Tree:
    /Users/will/github/my-project

Applications:
    Name   Mode     ExeType
    -----  -------  -------
    myapp  Console  kit    

Required Packages:
    Tcl  8.6.1  

Distribution Sets:
    install
</example>

In this listing we see the project's name, and its initial version string
('<tt 0.0a0>') and description.  It contains code for one application,
'<tt myapp>', which is a console-mode application to be delivered as a 
starkit.  The project has only one dependency, on Tcl 8.6.1, which is the
version of Tcl currently installed on the machine in use.  It defines a 
single distribution set, '<tt install>', which in turn defines the files to
be included in the installation .zip file.<p>

Typically you will wish to change some or all of these things.  You might 
want a GUI application built as a standalone executable, and you'll probably
have additional external dependencies.  Ultimately you'll need to change
the version number.<p>

All of these things are defined in the <i project file>, which is called
<tt project.quill>.<p>

<section using.projfile "The Project File">

The project file is the heart of the Quill system.  Everything Quill needs
to know about your project is put into the project file, which resides in 
the root directory of your project's directory tree.  Here is the project
file for the project we just created in the previous section:<p>

<example>
$ <b cd ~/github/my-project>
$ <b cat project.quill>
project my-project 0.0a0 "Your project description"
homepage http://home.page.url
app myapp
require Tcl 8.6.1

dist install {
    %apps
    docs/*.html
    docs/man*/*.html
    README.md
    LICENSE
}
</example>

The project file consists of a sequence of statements that define the
entities in the project.  It always begins with the <tt project> statement,
which defines the project's name, version number, and description.  The
<tt app> statement declares that the project defines an application called
'<tt myapp>', and that it requires version 8.6.1 of a package called 'Tcl'.
Finally, it defines an installation set called 'install' which contains 
the built applications, some HTML files from the 
<root docs/> subtree, and the README and LICENSE files.<p>

The file is usually edited by hand; to change the project's version number,
just edit the file.  Then, run '<tt quill info>' to verify that the file is
readable:<p>

<example>
$ <b vim project.quill>
$ <b quill info>
...
$
</example>

In addition to the kind of information shown above, you can also 
<tt provide> library packages; these are Tcl libraries exported by your
project for use by other project.<p>

The project file syntax is documented in Quill's 
<xref project(5)> man page.  It's a Tcl-formatted file, naturally, but
it allows only the commands defined in <xref project(5)>; and on occasion
Quill will write it out again with edits, so you shouldn't get too attached
to your formatting.<p>

<section using.projfile.autoupdate "Automatic Code Updates">

Your project code will depend on some of the metadata defined in the 
project file.  For example, any library packages in your project
will have the same version number as the project itself; and naturally 
this project number needs to appear in the code in a variety of places
(i.e., in <tt package ifneeded> and <tt package provide> statements).<p>

Similarly, your applications will need to <tt package require> some or
all of the external dependencies list in <tt project.quill>, and will
need to include the package version numbers.<p>

Quill handles all of this.  Each time a Quill command is executed in the
project tree. Quill loads <tt project.quill> and updates the project's 
codebase as needed to match the project's new metadata.<p>

This is another reason why it is a good idea to execute 
'<tt quill info>' after editing <tt project.quill>: it gives Quill a chance
to make any necessary changes.<p>

<section using.projfile.quillinfo "The quillinfo(n) Package">

In addition to updating version numbers in the relevant 
<tt package ifneeded>, <tt package provide>, and <tt package require> 
statements, Quill also creates a library package, <xref quillinfo(n)>,
that contains all of the project's metadata, for use by your applications.
<p>

As an example, your application can retrieve the project version number
like this:<p>

<example>
set version [quillinfo version]
</example>

See the <xref quillinfo(n)> man page for the complete API.  Only a few
pieces of information are made available at present, but in principle
everything in <tt project.quill> can be made available.<p>

<section using.projtree "The Project Tree">

There are a nearly infinite number of ways to set up a project directory
tree; some of those ways work well, and some do not.  A succesful project
tree is the result of many small decisions, each of which makes the pieces 
work well together, and many of which are not obvious ahead of time.<p>

But if there are many bad project trees, there are many good ones; the
choice is to some extent arbitrary.  Quill makes the choice for you,
mandating a project tree layout that has been known to work in real 
projects.<p>

<topiclist>
<topicpath "<i root>/">
The project root directory.
</topicpath>

<topicpath "+project.quill">
The project file; see Section <xref using.projfile>.
</topicpath>

<topicpath "+README.md">
The project's "read me" file.
</topicpath>

<topicpath "+LICENSE">
The project's license file.
</topicpath>

<topicpath "+.quill/">
Quill's private working directory for this project.  It should not be 
checked into a VCS.
</topicpath>

<topicpath "+bin/">
The project "bin" directory.
</topicpath>

<topicpath "++<i app>.tcl">
Application loader script for application <i app>.
</topicpath>

<topicpath "++<i tool>">
A project-specific tool, usually a Tcl script.
</topicpath>

<topicpath "+docs/">
The project documentation directory.  See Section <xref using.docs>.
</topicpath>

<topicpath "++index.quilldoc">
The root of the project's documentation tree, in 
<xref quilldoc(5)> format.
</topicpath>

<topicpath "++<i document>.quilldoc">
Some other document, in <xref quilldoc(5)> format.
</topicpath>

<topicpath "++man1/">
Man page directory for application man pages.  (Section 1).
</topicpath>

<topicpath "+++<i app>.manpage">
Man page for application <i app> in <xref manpage(5)> format.
</topicpath>

<topicpath "++man5/">
Man page directory for project file formats.  (Section 5).
</topicpath>

<topicpath "+++<i format>.manpage">
Man page for the given file <i format> in <xref manpage(5)> format.
</topicpath>

<topicpath "++mann/">
Man page directory for Tcl package APIs.  (Section n).
</topicpath>

<topicpath "+++<i module>.manpage">
Man page for the given package <i module> in <xref manpage(5)> format.
</topicpath>

<topicpath "++mani/">
Man page directory for Tcl interfaces.  (Section i).
</topicpath>

<topicpath "+++<i interface>.manpage">
Man page for the given <i interface> in <xref manpage(5)> format. An
"interface" is a set of subcommands and semantics supported by multiple
otherwise unrelated Tcl objects.
</topicpath>

<topicpath "+lib/">
Parent directory for the project's Tcl packages.
</topicpath>

<topicpath "++app_<i app>/">
Directory for the application <i app>'s implementation package.
</topicpath>

<topicpath "+++pkgIndex.tcl">
The package's package index file.
</topicpath>

<topicpath "+++pkgModules.tcl">
The package's module loader script.  See Section <xref lib>
</topicpath>

<topicpath "+++main.tcl">
Defines the application's <tt main> procedure.
</topicpath>

<topicpath "+++<i module>.tcl">
Another package module.
</topicpath>

<topicpath "++<i lib>/">
Directory for package <i lib>, which might or might not be "provided" for
external use.
</topicpath>

<topicpath "+++pkgIndex.tcl">
The package's package index file.
</topicpath>

<topicpath "+++pkgModules.tcl">
The package's module loader script.  See Section <xref lib>
</topicpath>

<topicpath "+++<i module>.tcl">
Another package module.
</topicpath>

<topicpath "+<i test>/">
Parent directory for the project's test target directories.
</topicpath>

<topicpath "++<i target>/">
A test target directory.  The "<i target>" is usually a package name.
</topicpath>

<topicpath "+++/all_tests.test">
The target's main
<link http://www.tcl.tk/man/tcl8.6/TclCmd/tcltest.htm tcltest(n)>
script. (Boilerplate; See Section <xref testing>)
</topicpath>

<topicpath "+++/<i module>.test">
The tcltest(n) script for the given <i module>.
</topicpath>

</topiclist><p>

The practices and usage of these directories are discussed in the
following sections.  And, of course, you can define any other
subdirectories you need.<p>

<section using.projtree.quill "The Quill Tool and the Project Tree">

Some of Quill's subcommands need to be run within a project tree, and some
do not.  Of those that do, such as '<tt quill build>' and '<tt quill test>',
you can execute the command anywhere in the project tree; you do not need
to be in the project's root directory.<p>

<section using.test "Testing Your Project">

The '<tt quill test>' command executes all of your project's test targets,
displays a summary of the results:<p>

<example>
$ <b quill test>
Summarizing test results.  Use 'quill -verbose test'
to see the details.

app_quill:      Total   35  Passed  35  Skipped 0   Failed  0
quill:          Total   169 Passed  167 Skipped 2   Failed  0

$
</example>

You can execute a particular target or module test as well:<p>

<example>
$ <b quill test quill>
... output from running test/quill/all_tests.test ...

$ <b quill test quill listutils>
... output from running test/quill/listutils.test ...

$
</example>

Finally, you can add any 
<link http://www.tcl.tk/man/tcl8.6/TclCmd/tcltest.htm tcltest(n)>
options you like to the command line.  To run just one family of 
tests, for example, you can add the <tt -match> option:<p>

<example>
$ <b quill test quill listutils -match "lshift-*">
... output from running the lshift-* tests in listutils(n) ...

$
</example>

See Section <xref testing> for information on how to set up test target
directories for use with Quill.<p>

<section using.docs "Project Documentation">

Quill directly supports two documentation formats, <xref quilldoc(5)> and
<xref manpage(5)>.  The two formats are HTML-like, and share a great deal 
of their syntax.  Both are extensible in Tcl, and are translated into 
styled HTML.<p>

The <xref quilldoc(5)> format is for short HTML files and full documents
with section numbers, like this user's guide.  The <xref manpage(5)> format
is for man pages.  The <xref quilldoc(5)> and <xref manpage(5)> man pages
go into detail about the formats and how to make use of them.<p>

To format the documentation, use the '<tt quill docs>' command:<p>

<example>
$ <b quill docs>
... formats all .quilldoc and .manpage files found in the docs/ tree ...

$ <b quill docs mann>
... formats all manpages in docs/mann/ ...

$ <b quill docs docs>
... formats all .quilldoc files in docs/ ...

$ <b quill docs docs/ug.quilldoc>
... formats the specific file ...

$
</example>

If any errors are found, they are described in the console output.<p>

<section using.shell "Interactive Development">

When working with new code or debugging a problem, there is often no
substitute for opening a Tcl shell and exercising the code directly.  The
'<tt quill shell>' command supports this by invoking 
<link http://tkcon.sourceforge.net tkcon> in the context of your code 
base, with the <i auto_path> set so that your packages can be loaded.<p>

Further, if your project defines at least one application then 
'<tt quill shell>' automatically load the package for the first app in 
your <i project.quill> file. (The app's <tt main> procedure is not 
executed.)<p>

<i><b FUTURE:> The '<tt quill shell>' command will allow you to select the
app whose code you want loaded, or none.</i><p>

<section using.require "Managing External Dependencies">

Quill will manage your project's external dependencies; which is to say
the library packages written by others that are required by your project.
In particular, it will determine whether these libraries are available in
your local environment, and if necessary it will go acquire them from 
<tt teapot.activestate.com>.<p>

<b NOTE:> Before this mechanism will work properly, it may be necessary 
to set up your own local "teapot"; see 
Section <xref using.require.teapot>.<p>

External dependencies are declared in <tt project.quill> using the 
<xref project(5) require> statement:<p>

<example>
require snit 2.3
require mylib 1.2 -local
</example><p>

This example requires two packages, "snit" and "mylib".  The "mylib" 
package is declared to be "local", which is to say it's a package that's
built and installed locally; if it isn't available, there's no point 
in looking for it at <tt teapot.activestate.com>.<p>

To check whether all of your project's external dependencies are available
locally, use this:<p>

<example>
$ quill deps
Dependency Status:
  snit 2.3      (Missing)
  mylib 1.2     (OK)
</example><p>

To retrieve missing dependencies,<p>

<example>
$ quill deps update
...
</example><p>

Quill will attempt to retrieve all missing depedencies, and will report 
on its success or failure.

Finally, you can refresh any or all dependencies, explicitly downloading
a new copy, by using:<p>

<example>
$ quill deps refresh
...
</example><p>

<section using.require.code "Using Required Packages">

Quill makes sure that the declared dependencies are available; it does not
load them into your applications automatically.  This is because your project might define multiple applications and libraries, each of which may use a
subset of the declared dependencies.<p>

Instead, your applications and library packages must call 
<tt package require> in the usual way for each needed dependency.  However,
Quill does provide a mechanism to keep the package version numbers in sync
between <tt project.quill> and your code.  See Section <xref lib> for
details.<p>

<section using.require.teapot "Setting Up a Local Teapot">

ActiveTcl provides a local "teapot repository", which is a place to put
library packages such any script running on the local machine can access
them.  Quill requires that this local teapot be writable by the user; 
otherwise Quill can't update it to contain your project's external
dependencies.  Unfortunately, the standard installation locations for 
ActiveTcl on most platforms are such that the average user will <i>not</i>
have write access to the installation teapot.  If this is the case,
the user will need to create their own local teapot; and Quill can help.<p>

First, see if there is a problem:<p>

<example>
$ quill teapot
Teapot Status:
    Location:  /Users/<i name>/.quill/teapot
    Writable?  Yes
    Linked?    Yes

The local teapot is writable, and is properly linked
to the default Tcl shell.  

Everything appears to be OK.
</example>

In this the local teapot exists, and is writable, and everything is fine.
If you see output like this there is nothing more to do.<p>

The first time Quill is used, though, this is not likely to be the case.
To resolve the problem, then, do this:<p>

<example>
$ quill teapot fix
...
</example>

This command will do two things.  First, it will create a new local teapot
in your home directory, e.g., as <tt ~/.quill/teapot/>.  (The precise
location varies by operating system).  Being in your home directory, this
teapot is writable.<p>

Second, '<tt quill teapot fix>' will output a short script; executing this
script with admin privileges will link the new teapot to your development
<tt tclsh>, and will also resolve several issues related to running
the <tt teacup> executable with admin privileges.<p>

On a Linux or OSX system, for example, you would run this script 
using <tt sudo>:<p>

<example>
$ sudo ~/.quill/fixteapot
...
$
</example>

On Windows, the script would be called <tt fixteapot.bat>, and would need
to be run by a user with Admin privileges.<p>

The '<tt quill teapot fix>' command will output the script file's full path
name; you are encouraged to look at the script and verify that it isn't 
doing anything nefarious.<p>



<section using.lib "Providing Libraries">

A Quill project can define library packages for use by other projects.
Such a package is called a <i provided> package, because it is declared
using the <xref project(5) provide> statement in <tt project.quill>:<p>

<example>
provide mylib
</example><p>

Quill does two special things for provided packages.  First, on 
'<tt quill build>' Quill builds a teapot .zip file for the package.  This
.zip file is constructed so that it can be installed into any local 
teapot repository for use by other Tcl programs.  The file is stashed in
the <root .quill/teapot/> directory, and has a name like this:<p>

<tt>package-<i name>-<i version>-tcl.zip</tt><p>

where <i name> is the package name and <i version> is the package version.<p>

Second, '<tt quill install>' will install the package's .zip file into your
local teapot, for use by your other projects.<p>

And of course you can define a test target (Section <xref using.test>) and
man pages (Section <xref using.docs>) for the provided package, just as 
you can for any of the project's libraries.<p>

See Section <xref lib> for the structure of library packages, whether
provided or not.<p>

<i><b FUTURE:> At present, Quill requires TclDevKit to build the 
teapot .zip files.  This is expected to change in the near future.</i><p>

<section using.app "Providing Applications">

A project can also define applications for use by others.  Applications
are declared in <tt project.quill> using the <xref project(5) app> 
statement.  Applications may be delivered as starkits or starpacks
(standalone executables), and starpacks may be console or GUI applications.
For example, the following <tt app> statement defines a GUI application 
delivered as a standalone executable:<p>

<example>
app myapp -exetype exe -gui
</example>

The first <tt app> statement in <tt project.quill> defines the project's
<i primary> application.  Quill provides many tools for working with 
applications:<p>

'<tt quill run>' invokes the project's primary application, passing it any
command-line arguments.  This is convenient if you don't want to add the
project's <root bin/> directory to your <tt PATH>.<p>

'<tt quill shell>' loads the primary application's code into a
<tt tkcon> shell for interactive development and debugging.<p>

'<tt quill build>' builds the application as starkit or starpack in the
project's <root bin/> directory.  The executable will have a name like<p>

<tt><i name>-<i version>-tcl.kit</tt><p>

(for starkits) or<p>

<tt><i name>-<i version>-<i platform>[.exe]</tt><p>

for standalone executables, where the <i name> is the application name,
<i version> is the project version number, and <i platform> is the current 
platform string as returned by
<link http://www.tcl.tk/man/tcl8.6/TclCmd/platform.htm platform::identify>.<p>

And finally, '<tt quill install>' will install the application into the
user's <tt ~/bin> directory for local use as <tt><i name>.kit</tt>, 
<tt><i name>.exe</tt>, or simply <tt><i name></tt>, depending on the 
application and current platform.<p>

<i><b FUTURE:> At present, Quill requires TclDevKit in order to build the 
application executables. This will remain an option, but it is hoped that
other choices will be available in the future.</i><p>

<section using.dist "Building Distribution .zip Files">

So you've written your application or library, and you've installed it for
local use on your own machine; now you want to make it available to others.
Quill allows you to define one or more <i distribution sets>.  Each
distribution set is comprised of a name and a set of file patterns;
the '<tt quill dist>' command will build each distribution set as a .zip
file containing the files that match the patterns.<p>

Distribution sets are defined in <tt project.quill> using the
<xref project(5) dist> statement.  For example, a project that provides
a set of pure-Tcl libraries might have a distribution set like this:

<example>
dist install {
    %libs
    docs/*.html
    docs/man*/*.html
    README.md
    LICENSE
}
</example>

It includes the <tt .html> files from the project's documentation tree,
the project's README and LICENSE files, and the teapot .zip files for each
provided library, as indicated by the special pattern <tt %libs>.<p>

When built, this distribution set will result in a file with a name like 
this:<p>

<tt><i project>-<i version>-install.zip</tt><p>

where <i project> is the project's name and <i version> is the 
project's version number.<p>

If the project provides an application built as a starpack, it might have
an installation distribution set that looks like this:

<example>
dist install-%platform {
    %apps
    docs/*.html
    docs/man*/*.html
    README.md
    LICENSE
}
</example>

The <tt %apps> pattern is like the <tt %libs> pattern; it matches the
executable files built by '<tt quill build>'.<p>

The "<tt %platform>" in the distribution set name is present because 
starpack executables are specific to a particular platform; when the 
distribution set is built, the "%platform" token will be replaced with
the actual platform.  If it were built for a 32-bit Windows system, 
for example, the distribution .zip file would have a name like this:<p>

<tt><i project>-<i version>-install-win32_x86.zip</tt><p>

The project can define any number of distribution sets for different 
purposes.  For example, a project might want to define a "docs" 
distribution.<p>

<section using.buildall "Building the Project for Distribution">

Once your project is in good order, you can build it for distribution on
your development platform with one command:

<example>
$ quill build all
...
$
</example>

This command will:<p>

<ul>
<li> Verify all external dependencies.
<li> Run all tests.
<li> Format all documentation.
<li> Build teapot .zip files for all provided libraries.
<li> Build all app executables for the current platform.
<li> Build all distribution sets for the current platform.
</ul>

If there is a problem anywhere along the way, the build will halt with a 
detailed error message.<p>

<section using.buildfor "Building for Other Platforms">

Quill can build your applications for any platform for which you have
a basekit, provided that your application code and any local dependencies 
are all pure-Tcl.  (External dependencies from <tt teapot.activestate.com>
need not be pure-Tcl.)  The first step is acquire the required basekit(s); 
the second is to build your project using them.<p>

<section using.buildfor.basekits "Acquiring Basekits">

When building your apps for your development platform, Quill uses the
basekits delivered with ActiveTcl.  For other platforms you'll need to 
acquire the necessary basekits; and the easiest source is 
<tt teapot.activestate.com>.  Quill will manage this for you.

First, use the '<tt quill basekit>' command to see what 
basekits are available to you:<p>

<example>
$ quill basekit
Finding basekits at teapot.activestate.com...

Platforms for which cross-platform builds can be done:

platform                version         name             tcltk  source
----------------------  --------------  ---------------  -----  ------
linux-glibc2.3-ix86     8.6.3.0.298609  base-tcl-thread  tcl    web   
                                        base-tk-thread   tk     web   
                        8.6.1.1.298358  base-tcl-thread  tcl    local 
                        8.6.1.1.297892  base-tcl         tcl    web   
                                        base-tk          tk     web   
linux-glibc2.3-x86_64   8.6.3.0.298584  base-tcl-thread  tcl    web   
                                        base-tk-thread   tk     web   
                        8.6.2.1.298536  base-tcl-thread  tcl    local 
macosx-universal        8.6.0.0.296279  base-tcl-thread  tcl    web   
                                        base-tk-thread   tk     web   
macosx10.5-i386-x86_64  8.6.3.0.298584  base-tcl-thread  tcl    web   
                                        base-tk-thread   tk     web   
win32-ix86                              base-tcl-thread  tcl    web   
                                        base-tk-thread   tk     web   
                        8.6.2.1.298536  base-tk-thread   tk     local 
                        8.6.2.0.298433  base-tcl-thread  tcl    local 
win32-x86_64            8.6.3.0.298609  base-tcl-thread  tcl    web   
                                        base-tk-thread   tk     web   

$
</example>

Basekits with a source of "local" have already been downloaded to your
machine; basekits with a source of "web" are available for download.
Note that only Tcl 8.6 basekits are listed; that's because the project
I'm working on has the '<tt require Tcl 8.6>' statement in 
<tt project.quill>.  If it required Tcl 8.5, we'd see Tcl 8.5 basekits
instead.<p>

You then have your choices of the precise platform and version of Tcl,
whether you want the Tk GUI toolkit included, and whether you want threaded
or unthreaded Tcl (most distributions are now threaded).<p>

The next step is to retrieve the basekits you want using 
<tt quill basekit get>.  For example, to get threaded Tcl and Tk
basekits for all platforms for Tcl 8.6.2,<p>

<example>
$ quill basekit get "*" "8.6.2*" "*"
...
$
</example>

This command takes three arguments, the basekit name, the version, and
the platform; each argument can contain glob-style wildcard characters 
as shown.  (The double-quotes are to protect the wildcard characters from
your shell.)<p>

Quill will download all matching basekits and save them locally.  If you
wish to see which basekits you have available locally, use this command:<p>

<example>
$ quill basekit list -source local
Platforms for which cross-platform builds can be done:

platform               version         name             tcltk  source
---------------------  --------------  ---------------  -----  ------
linux-glibc2.3-ix86    8.6.1.1.298358  base-tcl-thread  tcl    local 
linux-glibc2.3-x86_64  8.6.2.1.298536  base-tcl-thread  tcl    local 
win32-ix86                             base-tk-thread   tk     local 
                       8.6.2.0.298433  base-tcl-thread  tcl    local 
$
</example>

See '<tt quill help basekit'> for the full syntax of the 
<tt 'quill basekit'> command.<p>

<section using.buildfor.build "Building with a Basekit">

To build your apps for a particular platform using a basekit, first 
acquire the needed basekit(s) as required above.  You'll want a 
'<tt base-tcl-*>' basekit for all non-GUI apps, and a 
'<tt base-tk-*>' basekit for
all GUI apps.  Then, use '<tt quill build all>' to build for your current
platform. (These steps can be done in either order).<p>

Then use '<tt quill build for>' for the desired platform.  For example,
to build for 32-bit Windows,<p>

<example>
$ quill build for win32-ix86
...
$
</example>

Quill will build all applications with <tt -exetype exe> using the locally available basekits for <tt win32-ix86> with the highest version number.  Then,
it will build any distribution sets that have '<tt %platform>' embedded 
in their names, substituting <tt win32-ix86> for '<tt %platform>'.<p>

This is why you must run '<tt quill build all>' before running 
'<tt quill build for>'; the latter builds only the applications, assuming
that any documentation and library teapot .zip files are already available.<p>

If you wish to run with a specific version or without threading (if both
threaded and unthreaded are available) you can use the <tt -version> and
<tt -threads> options.  See '<tt quill help build>' for specifics.<p>


<section using.element "Adding Elements to a Project">

<i><b FUTURE:> The '<tt quill add>' command will add application,
library, and other skeleton elements to your project using templates,
updating <tt project.quill> as required.</i><p>

In the mean time, the easiest way to add a new library or application is 
to copy and rename the required files and directories.  See 
Sections <xref lib>, <xref app>, and <xref testing> for complete
descriptions of Quill's expectations with regard to library packages,
applications, and test targets.<p>

<section using.config "Configuring Quill">

Quill typically requires very little configuration.  It will find your 
development <tt tclsh>, <tt tkcon>, <tt teacup>, <tt tclapp>, and basekits
on your path and use them without any further ado.  To see what tools
Quill plans to use, execute this command:<p>

<example>
$ quill env
Quill 0.3.0 thinks it is running on Mac OSX.

Local Teapot: /Users/will/.quill/teapot

Helper Tools:
    tclsh        /usr/local/bin/tclsh (v8.6.1)                                  
    tkcon        /usr/bin/tkcon                                                 
    teacup       /usr/local/bin/teacup (v8.5.15.1.298288)                       
    tclapp       /usr/local/bin/tclapp                                          
    basekit.tcl  /Library/Tcl/basekits/base-tcl8.6-thread-macosx10.5-i386-x86_64
    basekit.tk   /Library/Tcl/basekits/base-tk8.6-thread-macosx10.5-i386-x86_64 
    teapot-pkg   /usr/local/bin/teapot-pkg                                      

!  - Helper tool could not be found on disk.
+  - Path is configured explicitly.
</example>

If you have multiple versions of any tool on your system, or if Quill
cannot locate the required tools, you can use the 
'<tt quill config>' command to tell Quill where to find them:<p>

<example>
$ quill config list
... list of configuration parameters and value ...
$ quill config set helper.tclsh <i pathToTclShell>...
$
</example>

See '<tt quill help config>' for the complete syntax of the 
'<tt quill config>' command.<p>









<== ====================================================================>

<section lib "Library Packages">

This section explains how Quill manages TCL library packages.
A Quill project can contain three different kinds of Tcl library:

<ul>
<li> <b Provided packages>: I.e., those written to be used by other 
     projects.  These are named in the <xref using.projfile "project file">
     using the <xref project(5)#provide> statement.<p>

<li> <b Application implementation packages>:  Each application in a Quill
     project is represented as a loader script and an implementation
     package.  If the application is called <tt><i name></tt>, then its 
     implementation package is called <tt><i name>app</tt>.<p>

<li> <b Application infrastructure packages>:  A project may define a number
     of library packages to be used solely by the project's own 
     applications.<p>
</ul>

A project library called <i name>, of any of these three kinds, resides in
the project's <root "lib/<i name>"> directory.<p>

At least one library package is included in each new project.  Additional
packages can be added using the <tt quill add> command (not yet implemented)
or by hand, by copying an existing library.<p>

Quill has some very specific expectations of project library packages; for
the details, see the following subsections.<p>

<section lib.pkgIndex "The 'pkgIndex.tcl' File">

Every library package will have its <tt pkgIndex.tcl> file.  These are usually
created with the library package by Quill.  Here is a typical library 
package:<p>

<listing>
#-------------------------------------------------------------------------
# TITLE: 
#    pkgIndex.tcl
#
# PROJECT:
#    my-project: Your project description <mark A>
#
# DESCRIPTION:
#    mylib(n): pkgIndex file
#
#    Generated by Quill
#
#-------------------------------------------------------------------------

# -quill-ifneeded-begin <mark B> DO NOT EDIT BY HAND <mark C>
package ifneeded mylib 1.2.3 <mark D> [list source [file join $dir pkgModules.tcl]] <mark E>
# -quill-ifneeded-end <mark B>
</listing>

<topiclist>
<topic "<bigmark A>">
Quill uses your project's metadata when creating the file header.<p>
</topic>

<topic "<bigmark B>">
These are Quill block markers.  They are used to mark code segments that
Quill will update automatically, as needed.<p>
</topic>

<topic "<bigmark C>">
The contents of this kind of block (<tt quill-ifneeded-*>) is replaced in
its entirety; do not edit the code between the markers.<p>
</topic>

<topic "<bigmark D>">
The <tt package ifneeded> command loads the package's code when TCL is asked
to <tt package require> it, and references the package's name and version
number.  The version number of a package in a Quill project is always the 
same as the project version number.  When the version number changes, 
Quill will update this command with the latest version number.<p>
</topic>

<topic "<bigmark E>">
The package's code is loaded by calling the module's 
<tt pkgModules.tcl> file.  See <xref lib.pkgmodules>.<p>
</topic>

</topiclist>

<section lib.pkgmodules "The 'pkgModules.tcl' File">

A package's code is loaded by sourcing the package's
<tt pkgModules.tcl> file, which then sources the individual package
modules.  The <tt pkgModules.tcl> file is usually created automatically
by Quill, and then updated by the user as needed (see below).  Here is
a typical <tt pkgModules.tcl> file:<p>

<listing>
#-------------------------------------------------------------------------
# TITLE: 
#    pkgModules.tcl
#
# PROJECT:
#    my-project: Your project description <mark A>
#
# DESCRIPTION:
#    mylib(n): Package Loader
#
#    Generated by Quill
#
#-------------------------------------------------------------------------

#-------------------------------------------------------------------------
# Provide Package

# -quill-provide-begin <mark B> DO NOT EDIT BY HAND <mark C>
package provide mylib 1.2.3 <mark D>
# -quill-provide-end <mark B>

#-------------------------------------------------------------------------
# Require Packages

# -quill-require-begin <mark B> INSERT PACKAGE REQUIRES HERE <mark E>
package require snit 2.3 <mark F>
package require -exact myotherlib 1.2.3 <mark G>
# -quill-require-end <mark B>

#-------------------------------------------------------------------------
# Get the library directory

namespace eval ::mylib:: <mark H> {
    variable library [file dirname [info script]] <mark I>
}

source [file join $::mylib::library mymodule.tcl] <mark J>
...
</listing>

<topiclist>
<topic "<bigmark A>">
Quill uses your project's metadata when creating the file header.<p>
</topic>

<topic "<bigmark B>">
These are Quill block markers.  They are used to mark code segments that
Quill will update automatically, as needed.<p>
</topic>

<topic "<bigmark C>">
The contents of this kind of block (<tt quill-provide-*>) is replaced in
its entirety; do not edit the line between the markers.<p>
</topic>

<topic "<bigmark D>">
The <tt package provide> command notifies TCL that the given version of the
package is available to be required and used.  The version number for a
package in a Quill project is always the same as the project's version 
number, so Quill automatically updates this code when the project
version number changes.<p>
</topic>

<topic "<bigmark E>">
Your package's <tt package require> commands should go between these
<tt quill-require-*> marks, so that Quill can keep the version numbers
up to date.  Quill updates only the lines whose first non-whitespace
tokens are "package require".<p>
</topic>

<topic "<bigmark F>">
In this line, Snit is an external dependency named in the 
<xref using.projfile "project file"> using the <xref project(5)#require>
statement.  Quill consequently knows the required version number, and
will make sure to keep this command up-to-date with it.<p>
</topic>

<topic "<bigmark G>">
In this line, <tt myotherlib> is another library provided by this same
project.  In this case, Quill not only keeps the version number up-to-date
with the project's version number, it adds the <tt -exact> flag.
<tt myotherlib> might exist in the local teapot repository
as well as in the project tree, and using <tt -exact> ensures that 
<tt mylib> will load the version in the same project tree 
during development and a consistent version when deployed.<p>
</topic>

<topic "<bigmark H>">
Every package defines a namespace of the same name, just as a matter of 
convention.  Provided packages should usually put their code in the 
package namespace; for application and infrastructure packages, it's a
matter of taste.<p>
</topic>

<topic "<bigmark I>">
Every package saves the path its library directory in a variable called
<tt library> in its namespace.  This variable has multiple uses.  If
the package has resources (e.g., image files) that need to be loaded
at runtime, it can find them relative to this path.  And if it isn't
clear which version of a package is being loaded, a glance at the 
<tt library> variable will usually make things plain.<p>
</topic>

<topic "<bigmark J>">
The package's modules should always be sourced using this idiom, which 
is guaranteed to work on all platforms.<p>
</topic>
</topiclist>

There are two temptations to be avoided with regard to this file.

First, do not try to change the file name.  The consistent use of the
name <tt pkgModules.tcl> allows Quill to find it and update it properly
as version numbers change.<p>

Second, do not put your package's implementation at the tail end of the
<tt pkgModules.tcl> file, even if you have only one file.  Instead, put the
implementation in another file or files, and update <tt pkgModules.tcl> 
only when adding or deleting a module or a <tt package require>.<p>

<section lib.modules "Normal Package Modules">

The library package's code goes in one or more normal <tt .tcl> files, 
which are sourced by the package's
<tt pkgModules.tcl> file (see Section <xref lib.pkgmodules>).
They typically look like this:<p>

<listing>
#-------------------------------------------------------------------------
# TITLE: 
#    mymodule.tcl
#
# PROJECT:
#    mylib: Your project description <mark A>
#
# DESCRIPTION:
#    mylib(n): my module for this and that
#
#-------------------------------------------------------------------------

<mark B>

#-------------------------------------------------------------------------
# Exported Commands

namespace eval ::mylib {
    namespace export myproc <mark C>
}

#-------------------------------------------------------------------------
# Commands

# myproc text
#
# Dummy procedure

proc ::mylib::myproc {text} { <mark D>
    puts "Hello, $text!"
}
</listing>

<topiclist>
<topic "<bigmark A>">
Quill uses your project's metadata when creating the file header.
Update it to describe your module as desired.<p>
</topic>

<topic "<bigmark B>">
Notice that there are no <tt package require> or <tt package provide>
commands here.  Those go in <tt pkgModules.tcl>; see 
<xref lib.pkgmodules>.<p>
</topic>

<topic "<bigmark C>">
If you put the module's code in the package namespace, you might want to
export some commands.<p>
</topic>

<topic "<bigmark D>">
This part is up to the user.<p>
</topic>
</topiclist>

<== ====================================================================>

<section app "Application Structure">

TBD>

<== ====================================================================>

<section testing "Project Testing">

Quill provides easy management of your project test suite using the 
<tclref tcltest> test harness.  To execute all project tests,<p>

<example>
$ quill test
...
</example>

Quill will run all test targets, and output the results. Alternatively,
Quill will run a single test target given its name:<p>

<example>
$ quill test mylib
...
</example>

Test targets are defined by adding subdirectories to <root test/>; 
the name of the subdirectory is the name of the target.<p>

Each test directory contains an <tt all_tests.test> file, and one or
more normal <tclref tcltest> files, e.g., <tt mymodule.test>.  To run
a specific test file, add its name to the command line:<p>

<example>
$ quill test mylib mymodule
</example>

Finally, any options are passed along to <tt tcltest>:<p>

<example>
$ quill test mylib mymodule -match "mytest-1.*"
</example>


<section testing.stdfiles "Standard Test Files">

Each test 
subdirectory is assumed to contain a file called 
<tt all_tests.test>, plus any number of normal <tclref tcltest> files,
e.g., <tt mymodule.test>.<p>

The content of <tt all_tests.test> is pure boilerplate; it simply arranges
to execute all other <tt *.test> files in the directory, each in its 
own instance of the Tcl interpreter, and accumulate the results.  It is
generally created automatically by Quill, or by copying 
<tt all_tests.test> from an existing test subdirectory.<p>

Here is the skeleton of a typical module test script, as created by
Quill:<p>

<listing>
#-------------------------------------------------------------------------
# TITLE:
#    mymodule.test
#
# PROJECT:
#    myproject: Description of my project
#
# DESCRIPTION:
#    mymodule(n): Test Suite
#-------------------------------------------------------------------------

#-------------------------------------------------------------------------
# Load the tcltest package

if {[lsearch [namespace children] ::tcltest] == -1} { <mark A>
    package require tcltest 2.3
    eval ::tcltest::configure $argv
}

namespace import ::tcltest::test <mark B>

#-------------------------------------------------------------------------
# Load the package to be tested

source <mark C> ../../lib/mymodule/pkgModules.tcl <mark D>
namespace import ::mymodule::*

#-------------------------------------------------------------------------
# dummy

test dummy-1.1 {dummy test} -body {
    set a false
} -result {true}
</listing>

There are several things to note in the above listing:<p>

<topiclist>
<topic {<bigmark A>}>
The <tclref tcltest> package is loaded, and any options
passed to <tt quill test> are passed along to <tt tcltest>.<p>
</topic>

<topic {<bigmark B>}>
Only the <tt test> command is imported from the <tt tcltest::> namespace.
Used fully-qualified names for other <tclref tcltest> commands, or edit
this line to import additional commands.<p>
</topic>

<topic {<bigmark C>}>
The test script uses <tt source> to load the package, rather than
<tt package require>; if the library package is installed into the
local environment (not unusual), it can be difficult to ensure that 
<tt package require> always loads the code in the project tree.<p>
</topic>

<topic {<bigmark D>}>
Quill generally creates library packages and test directories together,
and assumes that the tests in the directory are for the package in the
<root lib> subdirectory of the same name.<p>


Also, notice that the test script sources the library package's 
<tt pkgModules.tcl> file.  By convention, all library packages in a 
Quill project have such a file; see <xref lib.pkgmodules> for details.<p>
</topic>
</topiclist>


<section testing.new "Adding New Test Targets">

At present each Quill project contains one test target, for the 
application's implementation package.  Ultimately, you will be
able to use the <tt quill add> command (FIXME) to add new
library packages, as well as new applications (each of which gets its
corresponding implementation package); each library created in this way
will each get its own test directory.<p>

In the meantime, test directories must be added by hand, usually by
copying an existing directory and changing the names.<p>

<== ====================================================================>


</document>
