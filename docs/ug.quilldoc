<document "Quill <version> User's Guide">

By Will Duquette<br>
<tt will -at- wjduquette.com><br>
October, 2014<p>

<hrule>
<contents>
<hrule>

<do {
# Define some infrastructure.
proc tclref {name} {
	return [link http://www.tcl.tk/man/tcl8.6/TclCmd/$name.htm ${name}(n)]
}
# For comment bars
proc == {args} {hrule}

# For project-relative paths
proc root {path} {
	return "[tt][i project]/[expand $path][/tt]"
}

}>

<preface intro "Introduction">

Quill is a tool for automating the various tasks involved in developing,
testing, documenting, and distributing a modern Tcl/Tk application.  It
was inspired by <link http://leiningen.org Leiningen>, a similar tool for
the Clojure programming language, a tool whose convenience and ease of use
made me distinctly jealous.<p>

Quill is intended for those learning Tcl/Tk for the first time, and also
for those who build libraries or applications in Tcl/Tk that are intended
for use by others.<p>

It is still a young project; if it doesn't yet meet your needs, please
leave an enhancement request at the 
<link https://github.com/wduquette/tcl-quill/issues "Quill issue tracker">.<p>

<preface ack "Acknowledgements">

Many thanks to the following people who have helped with Quill development:<p>

<ul>
<li> Ted Brunzie, for help with virtual machines
<li> Stephan Effelsberg, for Windows testing and diagnosis
<li> Andreas Kupries, for teapot troubleshooting
</ul>

<section over "Quill Overview">

This user's guide assumes that Quill is already installed; see
<link INSTALL.md> for details on how to install Quill.  If you don't
have Quill, you can find the latest release at the
<link https://github.com/wduquette/tcl-quill/releases "Quill Release Page">

Quill will help you do the following things:<p>

<ul>
<li> Set up an initial project tree for your application or library project.
<li> Manage any external dependencies (i.e., library packages) your project
     needs, downloading them from <tt teapot.activestate.com> as needed.
<li> Execute your tests, summarizing the results.
<li> Allow you to exercise your code in an interactive shell.
<li> Allow you to run arbitrary scripts against your code base.
<li> Format your project documentation.
<li> Build your library packages as teapot .zip files, and install them 
     into your local teapot.
<li> Build your applications as starkits or starpacks for your current
     platform, and install them for local use.
<li> Build distribution .zip files.
<li> Build your applications as starpacks against basekits for other 
     platforms.
<li> Manage your collection of basekits.
<li> Manage your local teapot repository.
<li> <b>Test your code, format your documentation, build your libraries
     and applications, and prepare them for distribution, with a single
     command.</b>
</ul>

Of course, you can do almost all of these things without Quill...but Quill
aims to make them so easy that all you need to do is write your code.<p>

<section using "Using Quill">

<b TBD:> We need to cover these topics.

<ul>
<li> Starting a New Project
<li> The Project Tree
<li> The Project File
<li> Running Tests
<li> Interactive Development
<li> Formatting Documentation
<li> Building and Installing Libraries
<li> Building and Installing Applications
<li> Distribution Sets
<li> Managing External Dependencies
<li> Building for Distribution
<li> Building for Other Platforms
<li> Adding Elements to an Existing Project
<li> Configuring Quill for your Environment
</ul>

<section using.tool "The Quill Command-line Tool">

Quill is a command-line tool with many subcommands, just like so many 
other software development tools.  To see what tools are available, 
enter '<tt quill>' or '<tt quill help>' at the command line.  To get help about a
specific subcommand, enter '<tt>quill help <i subcommand></tt>'.<p> 

<section using.newproject "Starting a New Project">

A Quill <i>project</i> is the collection of files related to a Tcl application
or library package (or both together).  To begin working with Quill, then,
the first thing to do is create a new project.  And the first thing to do
when starting a new project is to choose the most suitable project template.<p>

<i><b FUTURE:> Quill will support multiple project templates.  At present,
it supports a single template, '<tt app>', for a generic application.</i><p>

To create a new project, switch to the parent directory of the new project's
directory tree, and use the '<tt quill new>' tool:<p>

<example>
$ cd ~/github
$ quill new app my-project myapp
...
$ cd my-project
$ quill info
...
</example>

The '<tt quill new>' command takes the project template name ('<tt app>')
and the project name, ('<tt my-project>'), and any additional information 
required by the template (the application name, 'myapp', in this case).  
It creates  a project tree for the project, rooted at 
<tt my-project/> in the current directory.<p>

The '<tt quill info>' command displays the new project's metadata in a 
human-readable form:<p>

<example>
$ quill info
my-project 0.0a0: Your project description

Project Tree:
    /Users/will/github/my-project

Applications:
    Name   Mode     ExeType
    -----  -------  -------
    myapp  Console  kit    

Required Packages:
    Tcl  8.6.1  

Distribution Sets:
    install
</example>

In this listing we see the project's name, and its initial version string
('<tt 0.0a0>') and description.  It contains code for one application,
'<tt myapp>', which is a console-mode application to be delivered as a 
starkit.  The project has only one dependency, on Tcl 8.6.1, which is the
version of Tcl currently installed on the machine in use.  It defines a 
single distribution set, '<tt install>', which in turn defines the files to
be included in the installation .zip file.<p>

Typically you will wish to change some or all of these things.  You might 
want a GUI application built as a standalone executable, and you'll probably
have additional external dependencies.  Ultimately you'll need to change
the version number.<p>

All of these things are defined in the <i project file>, which is called
<tt project.quill>.<p>

<section using.projfile "The Project File">

The project file is the heart of the Quill system.  Everything Quill needs
to know about your project is put into the project file, which resides in 
the root directory of your project's directory tree.  Here is the project
file for the project we just created in the previous section:<p>

<example>
$ cd ~/github/my-project
$ cat project.quill
project my-project 0.0a0 "Your project description"
homepage http://home.page.url
app myapp
require Tcl 8.6.1

dist install {
    %apps
    docs/*.html
    docs/man*/*.html
    README.md
    LICENSE
}
</example>

The project file consists of a sequence of statements that define the
entities in the project.  It always begins with the <tt project> statement,
which defines the project's name, version number, and description.  The
<tt app> statement declares that the project defines an application called
'<tt myapp>', and that it requires version 8.6.1 of a package called 'Tcl'.
Finally, it defines an installation set called 'install' which contains 
the built applications, some HTML files from the 
<root docs/> subtree, and the README and LICENSE files.<p>

The file is usually edited by hand; to change the project's version number,
just edit the file.  Then, run '<tt quill info>' to verify that the file is
readable:<p>

<example>
$ vim project.quill
$ quill info
...
$
</example>

In addition to the kind of information shown above, you can also 
<tt provide> library packages; these are Tcl libraries exported by your
project for use by other project.<p>

The project file syntax is documented in Quill's 
<xref project(5)> man page.  It's a Tcl-formatted file, naturally, but
it allows only the commands defined in <xref project(5)>; and on occasion
Quill will write it out again with edits, so you shouldn't get too attached
to your formatting.<p>

<section using.projfile.autoupdate "Automatic Code Updates">

Your project code will depend on some of the metadata defined in the 
project file.  For example, any library packages in your project
will have the same version number as the project itself; and naturally 
this project number needs to appear in the code in a variety of places
(i.e., in <tt package ifneeded> and <tt package provide> statements).<p>

Similarly, your applications will need to <tt package require> some or
all of the external dependencies list in <tt project.quill>, and will
need to include the package version numbers.<p>

Quill handles all of this.  Each time a Quill command is executed in the
project tree. Quill loads <tt project.quill> and updates the project's 
codebase as needed to match the project's new metadata.<p>

This is another reason why it is a good idea to execute 
'<tt quill info>' after editing <tt project.quill>: it gives Quill a chance
to make any necessary changes.<p>

<section using.projfile.quillinfo "The quillinfo(n) Package">

In addition to updating version numbers in the relevant 
<tt package ifneeded>, <tt package provide>, and <tt package require> 
statements, Quill also creates a library package, <xref quillinfo(n)>,
that contains all of the project's metadata, for use by your applications.
<p>

As an example, your application can retrieve the project version number
like this:<p>

<example>
set version [quillinfo version]
</example>

See the <xref quillinfo(n)> man page for the complete API.  Only a few
pieces of information are made available at present, but in principle
everything in <tt project.quill> can be made available.<p>

<section using.projtree "The Project Tree">

TBD.
<== ====================================================================>

<section lib "Library Packages">

This section explains how Quill manages TCL library packages.
A Quill project can contain three different kinds of Tcl library:

<ul>
<li> <b Provided packages>: I.e., those written to be used by other 
     projects.  These are named in the <xref using.projfile "project file">
     using the <xref project(5)#provide> statement.<p>

<li> <b Application implementation packages>:  Each application in a Quill
     project is represented as a loader script and an implementation
     package.  If the application is called <tt><i name></tt>, then its 
     implementation package is called <tt><i name>app</tt>.<p>

<li> <b Application infrastructure packages>:  A project may define a number
     of library packages to be used solely by the project's own 
     applications.<p>
</ul>

A project library called <i name>, of any of these three kinds, resides in
the project's <root "lib/<i name>"> directory.<p>

At least one library package is included in each new project.  Additional
packages can be added using the <tt quill add> command (not yet implemented)
or by hand, by copying an existing library.<p>

Quill has some very specific expectations of project library packages; for
the details, see the following subsections.<p>

<section lib.pkgIndex "The 'pkgIndex.tcl' File">

Every library package will have its <tt pkgIndex.tcl> file.  These are usually
created with the library package by Quill.  Here is a typical library 
package:<p>

<listing>
#-------------------------------------------------------------------------
# TITLE: 
#    pkgIndex.tcl
#
# PROJECT:
#    my-project: Your project description <mark A>
#
# DESCRIPTION:
#    mylib(n): pkgIndex file
#
#    Generated by Quill
#
#-------------------------------------------------------------------------

# -quill-ifneeded-begin <mark B> DO NOT EDIT BY HAND <mark C>
package ifneeded mylib 1.2.3 <mark D> [list source [file join $dir pkgModules.tcl]] <mark E>
# -quill-ifneeded-end <mark B>
</listing>

<topiclist>
<topic "<bigmark A>">
Quill uses your project's metadata when creating the file header.<p>
</topic>

<topic "<bigmark B>">
These are Quill block markers.  They are used to mark code segments that
Quill will update automatically, as needed.<p>
</topic>

<topic "<bigmark C>">
The contents of this kind of block (<tt quill-ifneeded-*>) is replaced in
its entirety; do not edit the code between the markers.<p>
</topic>

<topic "<bigmark D>">
The <tt package ifneeded> command loads the package's code when TCL is asked
to <tt package require> it, and references the package's name and version
number.  The version number of a package in a Quill project is always the 
same as the project version number.  When the version number changes, 
Quill will update this command with the latest version number.<p>
</topic>

<topic "<bigmark E>">
The package's code is loaded by calling the module's 
<tt pkgModules.tcl> file.  See <xref lib.pkgmodules>.<p>
</topic>

</topiclist>

<section lib.pkgmodules "The 'pkgModules.tcl' File">

A package's code is loaded by sourcing the package's
<tt pkgModules.tcl> file, which then sources the individual package
modules.  The <tt pkgModules.tcl> file is usually created automatically
by Quill, and then updated by the user as needed (see below).  Here is
a typical <tt pkgModules.tcl> file:<p>

<listing>
#-------------------------------------------------------------------------
# TITLE: 
#    pkgModules.tcl
#
# PROJECT:
#    my-project: Your project description <mark A>
#
# DESCRIPTION:
#    mylib(n): Package Loader
#
#    Generated by Quill
#
#-------------------------------------------------------------------------

#-------------------------------------------------------------------------
# Provide Package

# -quill-provide-begin <mark B> DO NOT EDIT BY HAND <mark C>
package provide mylib 1.2.3 <mark D>
# -quill-provide-end <mark B>

#-------------------------------------------------------------------------
# Require Packages

# -quill-require-begin <mark B> INSERT PACKAGE REQUIRES HERE <mark E>
package require snit 2.3 <mark F>
package require -exact myotherlib 1.2.3 <mark G>
# -quill-require-end <mark B>

#-------------------------------------------------------------------------
# Get the library directory

namespace eval ::mylib:: <mark H> {
    variable library [file dirname [info script]] <mark I>
}

source [file join $::mylib::library mymodule.tcl] <mark J>
...
</listing>

<topiclist>
<topic "<bigmark A>">
Quill uses your project's metadata when creating the file header.<p>
</topic>

<topic "<bigmark B>">
These are Quill block markers.  They are used to mark code segments that
Quill will update automatically, as needed.<p>
</topic>

<topic "<bigmark C>">
The contents of this kind of block (<tt quill-provide-*>) is replaced in
its entirety; do not edit the line between the markers.<p>
</topic>

<topic "<bigmark D>">
The <tt package provide> command notifies TCL that the given version of the
package is available to be required and used.  The version number for a
package in a Quill project is always the same as the project's version 
number, so Quill automatically updates this code when the project
version number changes.<p>
</topic>

<topic "<bigmark E>">
Your package's <tt package require> commands should go between these
<tt quill-require-*> marks, so that Quill can keep the version numbers
up to date.  Quill updates only the lines whose first non-whitespace
tokens are "package require".<p>
</topic>

<topic "<bigmark F>">
In this line, Snit is an external dependency named in the 
<xref using.projfile "project file"> using the <xref project(5)#require>
statement.  Quill consequently knows the required version number, and
will make sure to keep this command up-to-date with it.<p>
</topic>

<topic "<bigmark G>">
In this line, <tt myotherlib> is another library provided by this same
project.  In this case, Quill not only keeps the version number up-to-date
with the project's version number, it adds the <tt -exact> flag.
<tt myotherlib> might exist in the local teapot repository
as well as in the project tree, and using <tt -exact> ensures that 
<tt mylib> will load the version in the same project tree 
during development and a consistent version when deployed.<p>
</topic>

<topic "<bigmark H>">
Every package defines a namespace of the same name, just as a matter of 
convention.  Provided packages should usually put their code in the 
package namespace; for application and infrastructure packages, it's a
matter of taste.<p>
</topic>

<topic "<bigmark I>">
Every package saves the path its library directory in a variable called
<tt library> in its namespace.  This variable has multiple uses.  If
the package has resources (e.g., image files) that need to be loaded
at runtime, it can find them relative to this path.  And if it isn't
clear which version of a package is being loaded, a glance at the 
<tt library> variable will usually make things plain.<p>
</topic>

<topic "<bigmark J>">
The package's modules should always be sourced using this idiom, which 
is guaranteed to work on all platforms.<p>
</topic>
</topiclist>

There are two temptations to be avoided with regard to this file.

First, do not try to change the file name.  The consistent use of the
name <tt pkgModules.tcl> allows Quill to find it and update it properly
as version numbers change.<p>

Second, do not put your package's implementation at the tail end of the
<tt pkgModules.tcl> file, even if you have only one file.  Instead, put the
implementation in another file or files, and update <tt pkgModules.tcl> 
only when adding or deleting a module or a <tt package require>.<p>

<section lib.modules "Normal Package Modules">

The library package's code goes in one or more normal <tt .tcl> files, 
which are sourced by the package's
<tt pkgModules.tcl> file (see Section <xref lib.pkgmodules>).
They typically look like this:<p>

<listing>
#-------------------------------------------------------------------------
# TITLE: 
#    mymodule.tcl
#
# PROJECT:
#    mylib: Your project description <mark A>
#
# DESCRIPTION:
#    mylib(n): my module for this and that
#
#-------------------------------------------------------------------------

<mark B>

#-------------------------------------------------------------------------
# Exported Commands

namespace eval ::mylib {
    namespace export myproc <mark C>
}

#-------------------------------------------------------------------------
# Commands

# myproc text
#
# Dummy procedure

proc ::mylib::myproc {text} { <mark D>
    puts "Hello, $text!"
}
</listing>

<topiclist>
<topic "<bigmark A>">
Quill uses your project's metadata when creating the file header.
Update it to describe your module as desired.<p>
</topic>

<topic "<bigmark B>">
Notice that there are no <tt package require> or <tt package provide>
commands here.  Those go in <tt pkgModules.tcl>; see 
<xref lib.pkgmodules>.<p>
</topic>

<topic "<bigmark C>">
If you put the module's code in the package namespace, you might want to
export some commands.<p>
</topic>

<topic "<bigmark D>">
This part is up to the user.<p>
</topic>
</topiclist>

<== ====================================================================>

<section testing "Project Testing">

Quill provides easy management of your project test suite using the 
<tclref tcltest> test harness.  To execute all project tests,<p>

<example>
$ quill test
...
</example>

Quill will run all test targets, and output the results. Alternatively,
Quill will run a single test target given its name:<p>

<example>
$ quill test mylib
...
</example>

Test targets are defined by adding subdirectories to <root test/>; 
the name of the subdirectory is the name of the target.<p>

Each test directory contains an <tt all_tests.test> file, and one or
more normal <tclref tcltest> files, e.g., <tt mymodule.test>.  To run
a specific test file, add its name to the command line:<p>

<example>
$ quill test mylib mymodule
</example>

Finally, any options are passed along to <tt tcltest>:<p>

<example>
$ quill test mylib mymodule -match "mytest-1.*"
</example>


<section testing.stdfiles "Standard Test Files">

Each test 
subdirectory is assumed to contain a file called 
<tt all_tests.test>, plus any number of normal <tclref tcltest> files,
e.g., <tt mymodule.test>.<p>

The content of <tt all_tests.test> is pure boilerplate; it simply arranges
to execute all other <tt *.test> files in the directory, each in its 
own instance of the Tcl interpreter, and accumulate the results.  It is
generally created automatically by Quill, or by copying 
<tt all_tests.test> from an existing test subdirectory.<p>

Here is the skeleton of a typical module test script, as created by
Quill:<p>

<listing>
#-------------------------------------------------------------------------
# TITLE:
#    mymodule.test
#
# PROJECT:
#    myproject: Description of my project
#
# DESCRIPTION:
#    mymodule(n): Test Suite
#-------------------------------------------------------------------------

#-------------------------------------------------------------------------
# Load the tcltest package

if {[lsearch [namespace children] ::tcltest] == -1} { <mark A>
    package require tcltest 2.3
    eval ::tcltest::configure $argv
}

namespace import ::tcltest::test <mark B>

#-------------------------------------------------------------------------
# Load the package to be tested

source <mark C> ../../lib/mymodule/pkgModules.tcl <mark D>
namespace import ::mymodule::*

#-------------------------------------------------------------------------
# dummy

test dummy-1.1 {dummy test} -body {
    set a false
} -result {true}
</listing>

There are several things to note in the above listing:<p>

<topiclist>
<topic {<bigmark A>}>
The <tclref tcltest> package is loaded, and any options
passed to <tt quill test> are passed along to <tt tcltest>.<p>
</topic>

<topic {<bigmark B>}>
Only the <tt test> command is imported from the <tt tcltest::> namespace.
Used fully-qualified names for other <tclref tcltest> commands, or edit
this line to import additional commands.<p>
</topic>

<topic {<bigmark C>}>
The test script uses <tt source> to load the package, rather than
<tt package require>; if the library package is installed into the
local environment (not unusual), it can be difficult to ensure that 
<tt package require> always loads the code in the project tree.<p>
</topic>

<topic {<bigmark D>}>
Quill generally creates library packages and test directories together,
and assumes that the tests in the directory are for the package in the
<root lib> subdirectory of the same name.<p>


Also, notice that the test script sources the library package's 
<tt pkgModules.tcl> file.  By convention, all library packages in a 
Quill project have such a file; see <xref lib.pkgmodules> for details.<p>
</topic>
</topiclist>


<section testing.new "Adding New Test Targets">

At present each Quill project contains one test target, for the 
application's implementation package.  Ultimately, you will be
able to use the <tt quill add> command (FIXME) to add new
library packages, as well as new applications (each of which gets its
corresponding implementation package); each library created in this way
will each get its own test directory.<p>

In the meantime, test directories must be added by hand, usually by
copying an existing directory and changing the names.<p>

</document>
