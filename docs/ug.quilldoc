<document "Quill <version> User's Guide">

By Will Duquette<br>
September, 2014<p>

<hrule>
<contents>
<hrule>

<do {
# Define some infrastructure.
proc tclref {name} {
	return [link http://www.tcl.tk/man/tcl8.6/TclCmd/$name.htm ${name}(n)]
}
# For comment bars
proc == {args} {hrule}

# For project-relative paths
proc root {path} {
	return "[tt][i project]/[expand $path][/tt]"
}

}>

<preface intro "Introduction">

TODO: Why Quill came to be written.

<preface ack "Acknowledgements">

Many thanks to the following people who have helped with Quill development:<p>

<ul>
<li> Ted Brunzie, for help with virtual machines
<li> Stephan Effelsberg, for Windows testing and diagnosis
<li> Andreas Kupries, for teapot troubleshooting
</ul>

<section over "Quill Overview">

TODO: Gosh, there's a lot of work to be done here.<p>

<section over.tree "The Project Tree">
<section over.pfile "The Project File">

<section projfile "The Project File">

<== ====================================================================>

<section lib "Library Packages">

This section explains how Quill manages TCL library packages.
A Quill project can contain three different kinds of Tcl library:

<ul>
<li> <b Provided packages>: I.e., those written to be used by other 
     projects.  These are named in the <xref projfile "project file">
     using the <xref project(5)#provide> statement.<p>

<li> <b Application implementation packages>:  Each application in a Quill
     project is represented as a loader script and an implementation
     package.  If the application is called <tt><i name></tt>, then its 
     implementation package is called <tt><i name>app</tt>.<p>

<li> <b Application infrastructure packages>:  A project may define a number
     of library packages to be used solely by the project's own 
     applications.<p>
</ul>

A project library called <i name>, of any of these three kinds, resides in
the project's <root "lib/<i name>"> directory.<p>

<section lib.pkgIndex "The 'pkgIndex.tcl' File">

Every library package will have its <tt pkgIndex.tcl> file.  These are usually
created with the library package by Quill.  Here is a typical library 
package:<p>

<listing>
#-------------------------------------------------------------------------
# TITLE: 
#    pkgIndex.tcl
#
# PROJECT:
#    my-project: Your project description <mark A>
#
# DESCRIPTION:
#    mylib(n): pkgIndex file
#
#    Generated by Quill
#
#-------------------------------------------------------------------------

# -quill-ifneeded-begin <mark B> DO NOT EDIT BY HAND <mark C>
package ifneeded mylib 1.2.3 <mark D> [list source [file join $dir pkgModules.tcl]] <mark E>
# -quill-ifneeded-end <mark B>

</listing>

<topiclist>
<topic "<bigmark A>">
Quill uses your project's metadata when creating the file header.<p>
</topic>

<topic "<bigmark B>">
These are Quill block markers.  They are used to mark code segments that
Quill will update automatically, as needed.<p>
</topic>

<topic "<bigmark C>">
The contents of this kind of block (<tt quill-ifneeded-*>) is replaced in
its entirety; do not edit the line between the markers.<p>
</topic>

<topic "<bigmark D>">
The <tt package ifneeded> command loads the package's code when TCL is asked
to <tt package require> it, and references the package's name and version
number.  The version number of a package in a Quill project is always the 
same as the project version number.  When the version number changes, 
Quill will update this command with the latest version number.<p>
</topic>

<topic "<bigmark E>">
The package's code is loaded by calling the module's 
<tt pkgModules.tcl> file.  See <xref lib.pkgmodules>.<p>
</topic>

</topiclist>

<section lib.pkgmodules "The 'pkgModules.tcl' File">

TBD: Discuss pkgIndex.tcl, pkgModules.tcl.

<== ====================================================================>

<section testing "Project Testing">

Quill provides easy management of your project test suite using the 
<tclref tcltest> test harness.  To execute all project tests,<p>

<example>
$ quill test
...
</example>

Quill will run all test targets, and output the results. Alternatively,
Quill will run a single test target given its name:<p>

<example>
$ quill test mylib
...
</example>

Test targets are defined by adding subdirectories to <root test/>; 
the name of the subdirectory is the name of the target.<p>

Each test directory contains an <tt all_tests.test> file, and one or
more normal <tclref tcltest> files, e.g., <tt mymodule.test>.  To run
a specific test file, add its name to the command line:<p>

<example>
$quill test mylib mymodule
</example>

Finally, any options are passed along to <tt tcltest>:<p>

<example>
$quill test mylib mymodule -match "mytest-1.*"
</example>


<section testing.stdfiles "Standard Test Files">

Each test 
subdirectory is assumed to contain a file called 
<tt all_tests.test>, plus any number of normal <tclref tcltest> files,
e.g., <tt mymodule.test>.<p>

The content of <tt all_tests.test> is pure boilerplate; it simply arranges
to execute all other <tt *.test> files in the directory, each in its 
own instance of the Tcl interpreter, and accumulate the results.  It is
generally created automatically by Quill, or by copying 
<tt all_tests.test> from an existing test subdirectory.<p>

Here is the skeleton of a typical module test script, as created by
Quill:<p>

<listing>
#-------------------------------------------------------------------------
# TITLE:
#    mymodule.test
#
# PROJECT:
#    myproject: Description of my project
#
# DESCRIPTION:
#    mymodule(n): Test Suite
#-------------------------------------------------------------------------

#-------------------------------------------------------------------------
# Load the tcltest package

if {[lsearch [namespace children] ::tcltest] == -1} { <mark A>
    package require tcltest 2.3
    eval ::tcltest::configure $argv
}

namespace import ::tcltest::test <mark B>

#-------------------------------------------------------------------------
# Load the package to be tested

source <mark C> ../../lib/mymodule/pkgModules.tcl <mark D>
namespace import ::mymodule::*

#-------------------------------------------------------------------------
# dummy

test dummy-1.1 {dummy test} -body {
    set a false
} -result {true}
</listing>

There are several things to note in the above listing:<p>

<topiclist>
<topic {<bigmark A>}>
The <tclref tcltest> package is loaded, and any options
passed to <tt quill test> are passed along to <tt tcltest>.<p>
</topic>

<topic {<bigmark B>}>
Only the <tt test> command is imported from the <tt tcltest::> namespace.
Used fully-qualified names for other <tclref tcltest> commands, or edit
this line to import additional commands.<p>
</topic>

<topic {<bigmark C>}>
The test script uses <tt source> to load the package, rather than
<tt package require>; if the library package is installed into the
local environment (not unusual), it can be difficult to ensure that 
<tt package require> always loads the code in the project tree.<p>
</topic>

<topic {<bigmark D>}>
Quill generally creates library packages and test directories together,
and assumes that the tests in the directory are for the package in the
<root lib> subdirectory of the same name.<p>


Also, notice that the test script sources the library package's 
<tt pkgModules.tcl> file.  By convention, all library packages in a 
Quill project have such a file; see <xref lib.pkgmodules> for details.<p>
</topic>
</topiclist>


<section testing.new "Adding New Test Targets">

At present each Quill project contains one test target, for the 
application's implementation package.  Ultimately, you will be
able to use the <tt quill add> command (FIXME) to add new
library packages, as well as new applications (each of which gets its
corresponding implementation package); each library created in this way
will each get its own test directory.<p>

In the meantime, test directories must be added by hand, usually by
copying an existing directory and changing the names.<p>

</document>
